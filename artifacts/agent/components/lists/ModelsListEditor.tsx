import * as React from 'react';
import { memo, useState, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { PlusIcon } from '@/components/icons';
import { ModelEditor } from '../editors/ModelEditor';
import type { AgentModel, } from '../../types';
import { generateNewId } from '../../utils';

interface AgentArtifactMetadata {
  selectedTab: 'models' | 'actions' | 'schedules';
  editingModel: string | null;
  editingAction: string | null;
  editingSchedule: string | null;
  viewingModelData: string | null;
  editingRecord: string | null;
  currentStep?: string;
  stepProgress?: {
    'prompt-understanding'?: 'processing' | 'complete';
    'granular-analysis'?: 'processing' | 'complete';
    analysis?: 'processing' | 'complete';
    'change-analysis'?: 'processing' | 'complete';
  };
  dataManagement?: {
    viewingModelId: string;
    editingRecordId: string | null;
    isAddingRecord: boolean;
  } | null;
}

interface ModelsListEditorProps {
  models: AgentModel[];
  onModelsChange: (models: AgentModel[]) => void;
  updateMetadata: (updates: Partial<AgentArtifactMetadata>) => void;
  status: 'streaming' | 'idle';
}

export const ModelsListEditor = memo(({ 
  models, 
  onModelsChange, 
  updateMetadata, 
  status 
}: ModelsListEditorProps) => {
  const [editingModelId, setEditingModelId] = useState<string | null>(null);
  const [isAddingModel, setIsAddingModel] = useState(false);

  // Helper function to check if a model has a published field
  const hasPublishedField = useCallback((model: AgentModel): boolean => {
    return model.fields.some(field => field.name === 'published' && field.type === 'Boolean');
  }, []);

  const addModel = useCallback(() => {
    const newModel: AgentModel = {
      id: generateNewId('model', models || []),
      name: `Model${(models?.length || 0) + 1}`,
      emoji: 'üóÉÔ∏è', // Default emoji, will be auto-generated by AI
      idField: 'id',
      displayFields: [],
      fields: [
        {
          id: 'fld1',
          name: 'id',
          type: 'String',
          isId: true,
          unique: true,
          list: false,
          required: true,
          kind: 'scalar',
          relationField: false,
          title: 'ID',
          sort: false,
          order: 1
        },
        {
          id: 'fld2',
          name: 'published',
          type: 'Boolean',
          isId: false,
          unique: false,
          list: false,
          required: false,
          kind: 'scalar',
          relationField: false,
          title: 'Published',
          sort: false,
          order: 2,
          defaultValue: 'false'
        }
      ],
      enums: [],
      hasPublishedField: true
    };
    
    // Add to top of list and set to editing mode
    onModelsChange([newModel, ...(models || [])]);
    setEditingModelId(newModel.id);
  }, [models, onModelsChange]);

  const updateModel = useCallback((updatedModel: AgentModel) => {
    const updatedModels = models.map(model => 
      model.id === updatedModel.id ? updatedModel : model
    );
    onModelsChange(updatedModels);
  }, [models, onModelsChange]);

  const deleteModel = useCallback((modelId: string) => {
    const model = models.find(m => m.id === modelId);
    const modelName = model?.name || 'this model';
    
    if (window.confirm(`Are you sure you want to delete model "${modelName}"? This action cannot be undone and will remove all associated data.`)) {
      onModelsChange(models.filter(model => model.id !== modelId));
      if (editingModelId === modelId) {
        setEditingModelId(null);
      }
    }
  }, [models, onModelsChange, editingModelId]);

  const viewModelData = useCallback((modelId: string) => {
    console.log('üîç Data button clicked for modelId:', modelId);
    updateMetadata({
      dataManagement: {
        viewingModelId: modelId,
        editingRecordId: null,
        isAddingRecord: false
      }
    });
    console.log('üîç Called updateMetadata with viewingModelId:', modelId);
  }, [updateMetadata]);

  const backToModelsList = useCallback(() => {
    setEditingModelId(null);
    updateMetadata({ dataManagement: null });
  }, [updateMetadata]);

  if (editingModelId && models.find(m => m.id === editingModelId)) {
    const editingModel = models.find(m => m.id === editingModelId)!;
    return (
      <div className="space-y-6">
        <div className="flex items-center">
          <Button
            onClick={backToModelsList}
            className="btn-matrix px-4 py-2 mx-4"
          >
            ‚Üê Back
          </Button>
          <h3 className="text-2xl font-bold text-green-200 font-mono">Editing Model: {editingModel.name}</h3>
         
        </div>
        <ModelEditor
          model={editingModel}
          onUpdate={updateModel}
          onDelete={() => deleteModel(editingModel.id)}
          allModels={models}
          allEnums={editingModel.enums || []}
          updateModel={updateModel}
          allActions={[]}
        />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header - Updated to match Schedules style */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div className="flex flex-col sm:flex-row sm:items-center gap-3">
          <h3 className="text-xl sm:text-2xl font-bold text-green-200 font-mono">Data Models</h3>
          <div className="px-3 py-1 rounded-lg bg-green-800/50 border border-green-700">
            <span className="text-green-300 text-sm font-medium font-mono">{models.length} models</span>
          </div>
        </div>
        <Button 
          onClick={addModel}
          disabled={status === 'streaming'}
          className="btn-matrix px-3 sm:px-4 py-2"
        >
          <div className="flex items-center gap-2">
            <PlusIcon size={16} />
            <span>Add Model</span>
          </div>
        </Button>
      </div>

      <div className="grid gap-3 sm:gap-4">
        {models.map((model) => (
          <div key={model.id} className="p-4 sm:p-6 rounded-xl bg-green-500/10 border border-green-500/20 backdrop-blur-sm hover:border-green-500/40 transition-colors">
            {/* Mobile-first layout */}
            <div className="flex flex-col gap-4">
              {/* Top section with icon, title, and stats */}
              <div className="flex items-start gap-3 sm:gap-4">
                <div className="w-10 h-10 sm:w-12 sm:h-12 rounded-xl bg-green-500/20 flex items-center justify-center border border-green-500/30 flex-shrink-0">
                  <span className="text-lg sm:text-xl">{model.emoji || 'üóÉÔ∏è'}</span>
                </div>
                <div className="flex-1 min-w-0">
                  <h4 className="text-base sm:text-lg font-semibold text-green-200 font-mono break-words">{model.name || 'Unnamed Model'}</h4>
                  {model.description && (
                    <p className="text-green-300 text-xs sm:text-sm font-mono mt-1 opacity-80 leading-relaxed">
                      {/* Truncate on mobile for better layout */}
                      <span className="sm:hidden">
                        {model.description.length > 60 
                          ? `${model.description.substring(0, 60)}...` 
                          : model.description}
                      </span>
                      <span className="hidden sm:inline">
                        {model.description}
                      </span>
                    </p>
                  )}
                  {/* Stats row - responsive */}
                  <div className="flex flex-col sm:flex-row sm:items-center gap-1 sm:gap-4 mt-2">
                    <span className="text-green-400 text-xs sm:text-sm font-mono">
                      {model.fields.length} fields ‚Ä¢ {model.enums?.length || 0} enums
                    </span>
                    <span className="text-blue-400 text-xs sm:text-sm font-mono">
                      {model.records?.length || 0} records
                    </span>
                  </div>
                </div>
              </div>
              
              {/* Action buttons - Full width on mobile */}
              <div className="flex flex-col sm:flex-row gap-2 sm:gap-2 pt-2 sm:pt-0 border-t sm:border-t-0 border-green-500/10">
                <Button
                  onClick={() => setEditingModelId(model.id)}
                  size="sm"
                  className="btn-matrix px-3 py-2 text-xs sm:text-sm w-full sm:w-auto flex-1 sm:flex-none"
                >
                  <span>Edit Model</span>
                </Button>
                <Button
                  onClick={() => viewModelData(model.id)}
                  size="sm"
                  className="btn-matrix px-3 py-2 text-xs sm:text-sm w-full sm:w-auto flex-1 sm:flex-none"
                >
                  <div className="flex items-center gap-2 justify-center">
                    <span className="text-sm">üìä</span>
                    <span>View Data</span>
                  </div>
                </Button>
              </div>
            </div>
          </div>
        ))}

        {models.length === 0 && (
          <div className="text-center py-8 sm:py-12">
            <div className="w-16 h-16 sm:w-20 sm:h-20 mx-auto mb-4 rounded-2xl bg-green-800/30 flex items-center justify-center border border-green-500/20">
              <span className="text-2xl sm:text-4xl">üóÉÔ∏è</span>
            </div>
            <h4 className="text-lg sm:text-xl font-semibold text-green-300 mb-2 font-mono">No Models Defined</h4>
            <p className="text-green-500 text-sm font-mono mb-6 px-4">Create your first data model to get started</p>
            <Button 
              onClick={addModel}
              disabled={status === 'streaming'}
              className="btn-matrix px-4 sm:px-6 py-2 sm:py-3 w-full sm:w-auto max-w-xs"
            >
              <div className="flex items-center gap-2 justify-center">
                <PlusIcon size={16} />
                <span>Create First Model</span>
              </div>
            </Button>
          </div>
        )}
      </div>
    </div>
  );
}); 